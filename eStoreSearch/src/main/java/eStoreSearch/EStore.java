/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package eStoreSearch;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Scanner;
import java.util.StringTokenizer;

import javax.swing.*;

public class EStore {

    ArrayList<Product> productList = new ArrayList<Product>();

    private String searchID = null;
    private String searchKeywords = null;
    private ArrayList<String> keyWordList = new ArrayList<String>();
    private int searchYear1 = 0;
    private int searchYear2 = 0;
    private int yearRange = 0; //yearRange = 0; no year entered.
                               
                               /** 
                                * @return ArrayList<Product>
                                */
                               //          = 1; single year (YYYY)
                               //          = 2; range (start & end provided) (YYYY-YYYY)
                               //          = 3; before and including year entered (-YYYY)
                               //          = 4; after and including year entered (YYYY-)


/* * * * * * * * * * * * * * GETTERS * * * * * * * * * * * * * * */
public ArrayList<Product> getProductList(){
    return productList;
}


/** 
 * @param index
 * @return Product
 */
public Product getProductAt(int index){
    if (index < productList.size() && productList != null){
        return productList.get(index);
    }
    else {
        System.out.println("Error_getProductAt:  ProductList maximum index exceeded.");
        return null;
    }
}


/** 
 * @return Product
 */
public Product getLastAddedProduct(){
    if (productList != null){
        int lastIndex = productList.size() - 1;
        return productList.get(lastIndex);
    }
    else {
        return null;
    }
}


/** 
 * @return int
 */
public int getYearRange(){
    return yearRange;
}


/** 
 * @return int
 */
public int getSearchYear1(){
    return searchYear1;
}


/** 
 * @return int
 */
public int getSearchYear2 (){
    return searchYear2;
}


/** 
 * @return String
 */
public String getSearchKeywords (){
    return searchKeywords;
}


/** 
 * @return String
 */
public String getSearchID(){
    return searchID;
}


/** 
 * @param keyWordHash
 * @return boolean
 */
/* * * * * * * * * * * * * * SETTERS * * * * * * * * * * * * * * */


public boolean addNewProduct(Product newProduct, HashMap< String, ArrayList<Integer> > keyWordHash){
    
    if (newProduct != null) //if new product exists, add to list
    {
        productList.add(newProduct);
    }
    else {
        return false;
    }

    
    for (int i = 0; i < productList.size(); i++) {
        String descriptionKeys = productList.get(i).getDescription();
        StringTokenizer keywordTokenizer = new StringTokenizer( descriptionKeys );
        while (keywordTokenizer.hasMoreTokens()) //add each key word in description to hashmap
        {
            String keyword = keywordTokenizer.nextToken();
            keyword = keyword.toLowerCase();

           keyWordHash.putIfAbsent(keyword, new ArrayList<Integer>()); //if not already in arrayList, add new entry with new ArrayList for keyword indexes
           if (!(keyWordHash.get(keyword).contains(i))){
            keyWordHash.get(keyword).add(i); //add current index value to arrayList at hashed value
           }
            //System.out.println("key: " + keyword + " --> indexList: " + keyWordHash.get(keyword).toString() + "\n");
        }
    }
    return true;
}

public void resetSearchValues (){
    searchID = null;
    searchKeywords = null;
    keyWordList.clear();
    searchYear1 = 0;
    searchYear2 = 0;
    yearRange = 0;
}


/** 
 * @param yearString
 * @return boolean
 */
public boolean yearSearchDigitsValid(String yearString) {
    //check all chars are digits
    for (int i = 0; i < 4; i++){
        if ( !(yearString.charAt(i) >= 48 && yearString.charAt(i) <= 57) ) {
            System.out.println("Invalid Year Input.");
            return false;
        }
    }
    return true;
}


/** 
 * @param year
 * @return boolean
 */
public boolean yearSearchRangeValid(int year) {
    if (year >= 1000 && year <= 9999) {
        return true;
    }
    else {
        System.out.println("Year is out of range.  Please enter a year between 1000 - 9999");
        return false;
    }
}



/** 
 * @param year1
 * @param year2
 * @return boolean
 */
public boolean searchYear (int year1,  int year2){
  
    if (year1 > year2){
        int temp = year2;
        year2 = year1;
        year1 = temp;  
    }

    this.yearRange = 0;

        if (year1 != 0 && year2 == year1) {  //year format is (YYYY)
            if (yearSearchRangeValid(year1)) { //if year valid set search year values, and set year search type to YYYY (ie yearRange = 1)
                searchYear1 = year1;
                searchYear2 = 0;
                yearRange = 1;
                return true;
            }
            else {
                return false;
            }
        }

        else if (year1 == 0 && year2 != 0){  //year format is (-YYYY)
            if (yearSearchRangeValid(year2)){
                searchYear1 = year1;
                searchYear2 = 0;
                yearRange = 3;
                return true;
            }
            else {
                return false;
            }
        }

        else if (year2 == 0 && year1 != 0){  //year format is (YYYY-)
            if ( yearSearchRangeValid(year1) ){
                searchYear1 = year1;
                searchYear2 = 0;
                yearRange = 4;
                return true;
            }
            else {
                return false;
            }
        }
        
        if ( yearSearchRangeValid(year1) && yearSearchRangeValid(year2) ){
            searchYear1 = year1;
            searchYear2 = year2;
            yearRange = 2;
            return true;
        }
        else {
            return false;
        }
    }



/** 
 * @param keywords
 * @return ArrayList<String>
 */
public ArrayList<String> setSearchKeywords(String keywords){
    if (keywords != null){
        this.searchKeywords = keywords.toLowerCase();
        StringTokenizer tokenizer = new StringTokenizer(keywords.toLowerCase());
        while (tokenizer.hasMoreTokens()){
            this.keyWordList.add(tokenizer.nextToken());
        }
    
        return keyWordList;
    }
    else {
        return null;
    }
}


/** 
 * @param ID
 * @return boolean
 */
public boolean setSearchID(String ID){
    if (ID != null){
        this.searchID = ID;
        return true;
    }
    else {
        this.searchID = null;
        return false;
    }
}



/** 
 * @param newID
 * @return boolean
 */
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
public boolean uniqueID (String newID){
    //check all existing ID's
    if (productList != null){
        for (int i = 0; i < productList.size(); i++){
            if (productList.get(i).getProductID().equals(newID)){
                System.out.println("\nID already exists.");
                return false;
            }
        }
    }
    return true;
}


/** 
 * @return String
 */
public String searchValsToString(){
    return ("\nsearchID is:  " + searchID 
        + "\nsearchKeywords is:  " + searchKeywords
        +  "\nsearchYear1 is:  " + searchYear1 
        + "\nsearchYear2 is: " + searchYear2 
        + "\nyearRange is: " + yearRange);
}

public void printBookList (){
        Book book = new Book();
        System.out.println("\n\n---- BOOK LIST ----");
        for (int i = 0; i < productList.size(); i ++){
            if (productList.get(i).getClass() == book.getClass())
            {
                System.out.println(productList.get(i).toString() + "\n");
            }  
        }
}

public void printElectronicList (){
    Electronic electronic = new Electronic();
    System.out.println("\n\n---- ELECTRONIC LIST ----");
    for (int i = 0; i < productList.size(); i ++){
        if (productList.get(i).getClass() == electronic.getClass())
        {
            System.out.println(productList.get(i).toString() + "\n");
        }  
    }
}


/** 
 * @param outputDisplay
 */
public void printAllProducts(JTextArea outputDisplay){
        outputDisplay.setText("\n\n---- PRODUCT LIST ----");
        for (int i = 0; i < productList.size(); i ++){
            outputDisplay.setText(productList.get(i).toString() + "\n");
        }
}


/** 
 * @param keyWordHash
 * @return ArrayList<Integer>
 */
public ArrayList<Integer> keywordMatchSearch( HashMap< String, ArrayList<Integer> > keyWordHash)
{
ArrayList<Integer> matchesFoundIndexList = new ArrayList<Integer>();
String keywordChecking = new String();
//ArrayList<Product> productList is variable of object
//ArrayList <String> keywordList is variable of object
if (keyWordList != null) {
    for (int i = 0; i < productList.size(); i ++){
        int keywordMatchCount = 0;  //for each product set to zero
        for(int j = 0; j < keyWordList.size(); j++){
            keywordChecking = keyWordList.get(j);
             
            if (keyWordHash.containsKey(keywordChecking) && (keyWordHash.get(keywordChecking).contains(i))){
                keywordMatchCount++;
                continue;
            }
        }
        if (keywordMatchCount == keyWordList.size()) {
            //all keywords matched - add index to final list
            matchesFoundIndexList.add(i);
        }
    }
}
else {
    //if no words searched for, all products match criteria
    for (int i = 0; i < productList.size(); i ++){
        matchesFoundIndexList.add(i);
    } 
}
return matchesFoundIndexList;
}


/** 
 * @param keyWordHash
 * @param outputDisplay
 * @return ArrayList<Integer>
 */
public ArrayList<Integer> printProductListSearchMatches (int numSearchFields, HashMap< String, ArrayList<Integer> > keyWordHash, JTextArea outputDisplay){
    int fieldsMatch = 0;
    //searchID DEFAULT is null
    //searchKeyword DEFAULT is null
    ArrayList<Integer> indexFoundAray = keywordMatchSearch(keyWordHash);
    ArrayList<Integer> indicesPrinted = new ArrayList<Integer> ();
    if (numSearchFields < 0 || numSearchFields > 3){
        outputDisplay.append("Error_searchMatches: Invalid Number of Search Fields");
        return null;
    }
    outputDisplay.append("\n\n---- PRODUCT LIST ----\n");
    
    for (int i = 0; i < productList.size(); i ++){
        fieldsMatch = 0;
        
        //if searchID not default value, search for matches
        if (productList.get(i).getProductID().equals(searchID) && searchID != null){
            fieldsMatch++;
        }

        //if searchYears not default, search for matches
        if (this.yearRange == 1 && searchYear1 != 0){  //(YYYY)
            if (productList.get(i).getYear() == searchYear1){
                fieldsMatch ++;
            }
        }
        else if (this.yearRange == 2 && searchYear1 != 0 && searchYear2 != 0){ //(YYYY-YYYY)
            if (productList.get(i).getYear() >= searchYear1 && productList.get(i).getYear() <= searchYear2 ){
                fieldsMatch ++;
            }
        }
        else if (this.yearRange == 3 && searchYear1 != 0){ //(-YYYY)
            if (productList.get(i).getYear() <= searchYear1){
                fieldsMatch ++;
            }
        }
        else if (this.yearRange == 4 && searchYear1 != 0){ //(YYYY-)
            if (productList.get(i).getYear() >= searchYear1){
                fieldsMatch ++;
            }
        }
        
        //if searchKeywords not default, search for matches
        if (searchKeywords != null && indexFoundAray.contains(i)){
            fieldsMatch++;
        }
        if (fieldsMatch == numSearchFields){
            outputDisplay.append(productList.get(i).toString() + "\n");
            indicesPrinted.add(i);
        }
    }
    return indicesPrinted;
}



/** 
 * @param fullLineIn
 * @return String
 */
// * * * * * * * * * methods for mainline menu selections * * * * * * * * * * * * * * * //

public static String getDataFromFileLine(String fullLineIn) {
    String[] splitString = fullLineIn.split("\"");
    String data = new String ();
    try{
        data = splitString[1];
    } catch (ArrayIndexOutOfBoundsException e){
        data =  "";
    }
    return data;
}


/** 
 * @param keyboard
 * @return String
 */
public static String getFileName(Scanner keyboard){
    System.out.println("Reading productList from file");
    System.out.println("PLEASE ENTER NAME OF FILE TO READ PRODUCTLIST FROM"
            + "\n DO NOT INCLUDE FILE EXTENSION.  .TXT EXTENSION IS GENERATED AUTOMATICALLY");
    // get filename from user
    String fileNameIn = new String();
    keyboard.nextLine(); //catch newline char
    fileNameIn = keyboard.nextLine();
    StringTokenizer tokenizer = new StringTokenizer(fileNameIn);
    String fileName = tokenizer.nextToken();
    fileName = fileName.concat(".txt");
    System.out.println("read from file '" + fileName +"' .....\n\n");
    return fileName;
   }

   //public void addItemToInventory(Scanner keyboard, EStore eStore, HashMap< String, ArrayList<Integer> > keyWordHash)
  // {
    public void addItemToInventory(EStore eStore, HashMap< String, ArrayList<Integer> > keyWordHash, JTextArea outputDisplay, boolean isBook, String productID, String description, String priceString, String yearString, String authors, String publisher, String maker) throws Exception
    {

        Product newProduct;

        if (isBook == true){
            newProduct = new Book();
            maker = null;  
            if (((Book) newProduct).setAuthors(authors) == false) {
                outputDisplay.append("\nInvalid Authors.\n");
                throw new Exception ("m");
            }
            else if (((Book) newProduct).setPublisher(publisher) == false){
                outputDisplay.append("\nInvalid Publisher.\n");
                throw new Exception ("m");
            }

        }
        else {
            newProduct = new Electronic();
            authors = null;
            publisher = null;
            if (((Electronic) newProduct).setMaker(maker) == false) {
                outputDisplay.append("\nInvalid Maker.\n");
                throw new Exception ("m");
            }
        }

        //validity check
        try {
            if (eStore.uniqueID(productID) == false) { // if ID not unique, make user enter new one
                outputDisplay.append("\nNon-unique ProductID. Please choose a different product 6-digit ID.\n");
                throw new Exception ("m");
            }
            else if (newProduct.setProductID(productID) == false){
                outputDisplay.append("\nInvalid ProductID. Please choose a different product 6-digit ID.\n");
                throw new Exception ("m");
            }
            else if (newProduct.setYear(yearString) == false) {
                outputDisplay.append("\nInvalid Year Input. Please enter a integer year in range [1000,9999].\n");
                throw new Exception ("m");
            }
            else if (newProduct.setPrice(priceString) == false) {
                outputDisplay.append("\nInvalid Price Input.  Price has been set to default value of $0.\n");
                throw new Exception ("m");
            }
            else if (newProduct.setDescription(description) == false) {
                outputDisplay.append("\nInvalid Description Input.\n");
                throw new Exception ("m");
            }
        }
        catch (Exception m){
            outputDisplay.append("\nProduct was not added to inventory.\n");
            return;
        }

        //all values good... add newProduct to the EStore list.
        if (eStore.addNewProduct(newProduct, keyWordHash ) == true) {
                   System.out.println("\nNEW PRODUCT ADDED SUCCESSFULLY!\n");
                   System.out.print("Product list size is : " + eStore.productList.size());
                   System.out.print("\nNew Product Information: \n" + (eStore.getLastAddedProduct()).toString() + "\n");
                   outputDisplay.setText(" ");
       } else {
                   System.out.println("\nError:  new Product was not added.\n");
       }
      
}


/** 
 * @param keyWordHash
 */
public void readProductListFromFile( EStore eStore, String fileName, HashMap< String, ArrayList<Integer> > keyWordHash) {
       
    Scanner inputStream = null;
    
    StringTokenizer tokenizer = new StringTokenizer(fileName);
    try {
        inputStream = new Scanner(new FileInputStream(fileName));
    } catch (FileNotFoundException e) {
        System.out.println("File '" + fileName + "' could not be found or could not be opened.");
        System.out.println("\nProductList was not imported.\n");
        return;
    } catch (Exception e) {
        System.out.println("Error importing file. Caught by Exception e.");
    }

    if (!(inputStream.hasNextLine())) {
        System.out.println("Error: Input file is empty\n");
        System.out.println("\nProductList not imported.\n");
        return;
    }

    // temp variables for creating new products -- read in as strings then error
        // check before setting
        // ** since all required data in file surrounded by " ", just get part of
        // string between them

        String[] dataInArray = new String[7];  
            /// array index directory:
                // [0] typeIn
                // [1] productIDIn
                // [2] descriptionIn
                // [3] price
                // [4] yearIn
                // [5] authors/maker    --> books/electronic (type dependent)
                // [6] publisher  --> books only

    while (inputStream.hasNextLine()) {
        String currentLine = inputStream.nextLine();
        tokenizer = new StringTokenizer(currentLine);
        if (tokenizer.countTokens() == 0) // line was empty (just move on and read the next one)
        {
            continue;
        }

        // get product type
        dataInArray[0] = getDataFromFileLine(currentLine);
        if (dataInArray[0].equalsIgnoreCase("book") || dataInArray[0].equalsIgnoreCase("books")){
            for (int i = 1; i < 7 ; i ++){
                if (inputStream.hasNextLine()) {
                    currentLine = inputStream.nextLine();
                    dataInArray[i] = getDataFromFileLine(currentLine);    
                } else {
                    System.out.println("Error: File is not formatted correctly for data extraction.");
                    return;
                }
            }

            Book newBook = new Book();
            newBook.setPrice(dataInArray[3]);
            double priceIn = newBook.getPrice();
            newBook.setYear(dataInArray[4]);
            int yearIn = newBook.getYear();
            
            //check data is valid
            if ((newBook.setProductID(dataInArray[1]) == true)  
                && (newBook.setDescription(dataInArray[2]) == true)
                && (newBook.setPrice(dataInArray[3]) == true)
                && (newBook.setYear(dataInArray[4]) == true)
                && (newBook.setAuthors(dataInArray[5]) == true)
                && (newBook.setPublisher(dataInArray[6]) == true) ) {
                    try{
                        newBook = new Book(dataInArray[1], dataInArray[2], priceIn, yearIn, dataInArray[5], dataInArray[6]);
                    }
                    catch (Exception m) {
                        System.out.println("Constructor exception has occured. New Book was not created");
                    }
                    
                    if (eStore.uniqueID(newBook.getProductID())){
                    eStore.addNewProduct(newBook, keyWordHash );
                    System.out.println(newBook.toString());
                    }
                    else {
                        System.out.println("Item not added, product ID not unique.");
                    }
            }

        }
        else if (dataInArray[0].equalsIgnoreCase("electronic") || dataInArray[0].equalsIgnoreCase("electronics") ){
            for (int i = 1; i < 6 ; i ++){
                if (inputStream.hasNextLine()) {
                    currentLine = inputStream.nextLine();
                    dataInArray[i] = getDataFromFileLine(currentLine);
                } else {
                    System.out.println("Error: File is not formatted correctly for data extraction.");
                    return;
                }
            }

            Electronic newElectronic = new Electronic();
            newElectronic.setPrice(dataInArray[3]);
            double priceIn = newElectronic.getPrice();
            newElectronic.setYear(dataInArray[4]);
            int yearIn = newElectronic.getYear();

            //check data is valid
            if ((newElectronic.setProductID(dataInArray[1]) == true)  
                && (newElectronic.setDescription(dataInArray[2]) == true)
                && (newElectronic.setPrice(dataInArray[3]) == true)
                && (newElectronic.setYear(dataInArray[4]) == true)
                && (newElectronic.setMaker(dataInArray[5]) == true) ) {
                    try{
                        newElectronic = new Electronic(dataInArray[1], dataInArray[2], priceIn, yearIn, dataInArray[5]);
                    }
                    catch (Exception m) {
                        System.out.println("Constructor exception has occured. New Electronic was not created");
                    }
                    
                    if (eStore.uniqueID(newElectronic.getProductID())){
                    eStore.addNewProduct(newElectronic, keyWordHash);
                    System.out.println(newElectronic.toString());
                    }
                    else {
                        System.out.println("Item not added, product ID not unique.");
                    }
                }
        }
        else {
            System.out.println("Error: Invalid Product Type");
            return;
        }    
    }
    System.out.println("\nProductList successfully imported from " + fileName + ". \n");
    inputStream.close();
}


/** 
 * @param productList
 * @param fileName
 */
public void writeProductListToFile(ArrayList<Product> productList, String fileName)
{
    if (productList.size() == 0)
    {
        //if productlist empty, do not create file
        System.out.println("\nProduct List is empty, write file is currently invalid -- there is no information to write to file...");
        return;
    }

    Electronic testElectronic = new Electronic();   //sample of electronics subclass (will be used for class comparisons)
 
    PrintWriter outputStream = null;
    try {
        outputStream = new PrintWriter (new FileOutputStream(fileName));
    }
    catch (FileNotFoundException e) {
        System.out.println("Error opening the file " + fileName);
    }

    //copy classList into file
    for (int i = 0; i < productList.size(); i ++)
    {
        if (productList.get(i).getClass() == testElectronic.getClass()) //if currentProduct is an electronic
        {
            Electronic currentProduct = (Electronic)productList.get(i);
            System.out.println("type = \"electronic\"\n" + 
                                 "productID = \"" + currentProduct.getProductID() + "\"\n" + 
                                 "description = \"" + currentProduct.getDescription() + "\"\n" + 
                                 "price = \"" + currentProduct.getPrice() + "\"\n" + 
                                 "year = \"" + currentProduct.getYear() + "\"\n" + 
                                 "maker = \"" + currentProduct.getMaker() + "\"\n" 
                                 );

            outputStream.println("type = \"electronic\"\n" + 
                                 "productID = \"" + currentProduct.getProductID() + "\"\n" + 
                                 "description = \"" + currentProduct.getDescription() + "\"\n" + 
                                 "price = \"" + currentProduct.getPrice() + "\"\n" + 
                                 "year = \"" + currentProduct.getYear() + "\"\n" + 
                                 "maker = \"" + currentProduct.getMaker() + "\"\n" 
                                 );

        } else //all products that arent electronics must be books
        {
            Book currentProduct = (Book)productList.get(i);

            System.out.println("type = \"book\"\n" + 
                                 "productID = \"" + currentProduct.getProductID() + "\"\n" + 
                                 "description = \"" + currentProduct.getDescription() + "\"\n" + 
                                 "price = \"" + currentProduct.getPrice() + "\"\n" + 
                                 "year = \"" + currentProduct.getYear() + "\"\n" + 
                                 "authors = \"" + currentProduct.getAuthors() + "\"\n" +
                                 "publisher = \"" + currentProduct.getPublisher() + "\"\n"
                                 );

            outputStream.println("type = \"book\"\n" + 
                                 "productID = \"" + currentProduct.getProductID() + "\"\n" + 
                                 "description = \"" + currentProduct.getDescription() + "\"\n" + 
                                 "price = \"" + currentProduct.getPrice() + "\"\n" + 
                                 "year = \"" + currentProduct.getYear() + "\"\n" + 
                                 "authors = \"" + currentProduct.getAuthors() + "\"\n" +
                                 "publisher = \"" + currentProduct.getPublisher() + "\"\n"
                                 );

        }
    } 
    System.out.println("\nWriting to filename " + fileName + ". \n");
    outputStream.close();
}



/** 
 * @param keyWordHash
 * @param outputDisplay
 * @param searchID
 * @param searchKeywords
 * @param searchYear1
 * @param searchYear2
 */
public void searchForProduct( EStore eStore, HashMap< String, ArrayList<Integer> > keyWordHash, JTextArea outputDisplay, String searchID, String searchKeywords, String searchYear1, String searchYear2) {

outputDisplay.setText(" ");


int numSearchFields;

Product tempProduct = new Product();
eStore.resetSearchValues();
numSearchFields = 0;

int searchYear1Int;
int searchYear2Int;


    if (searchID.equals("") || tempProduct.setProductID(searchID) == false) {
        outputDisplay.append("No valid searchID input. Search parameter has been defaulted to null.\n");
        searchID = null;
    } 
    else {
        numSearchFields++;
    }

    if (searchKeywords.equals("") || (eStore.setSearchKeywords(searchKeywords).size() == 0)) {
        outputDisplay.append("No keywords search key selected.\n");
            searchKeywords = null;
    }
    else {
        numSearchFields++;
    }

    if ( (tempProduct.setYear(searchYear1) == false) || searchYear1.equals("") ){
        outputDisplay.append("No startYear search key selected.\n");
        searchYear1Int = 0;
    }    
    else {
        if (eStore.yearSearchDigitsValid(searchYear1)){
            searchYear1Int = tempProduct.getYear();
        }
        else {
            searchYear1Int = 0;
        }
        
        
    }
    if ( (tempProduct.setYear(searchYear2) == false) || searchYear2.equals("") ){
        outputDisplay.append("No endYear search key selected.\n");
        searchYear2Int = 0;
    }
    else {
        if (eStore.yearSearchDigitsValid(searchYear2)){
            searchYear2Int = tempProduct.getYear();
        }
        else {
            searchYear2Int = 0;
        }
    }
    if (eStore.searchYear(searchYear1Int, searchYear2Int) == false || (searchYear1Int == 0 && searchYear2Int == 0)) {
        outputDisplay.append("No startSearchYear search key selected.\n");
       
    } 
    else if (eStore.searchYear(searchYear1Int, searchYear2Int) == true) {
        numSearchFields++;
    }
    else {
        outputDisplay.append("Invalid input.");
        return;   
    }
    
        eStore.setSearchID(searchID);
        eStore.setSearchKeywords(searchKeywords);
        eStore.searchYear1 = searchYear1Int;
        eStore.searchYear2 = searchYear2Int;


System.out.println(eStore.searchValsToString());
System.out.println("numSearchFields is " + numSearchFields);
eStore.printProductListSearchMatches(numSearchFields, keyWordHash, outputDisplay); //*******************uncomment this later!!!!!!!!!!!!!!!
}


/** 
 * @param args
 */
public static void main(String[] args) {
        
    }
    
}
